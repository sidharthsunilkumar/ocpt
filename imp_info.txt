Time for process tree----------------------

OG - 3004.93s
With the 4 checking_cuts fns and info commented out - 346.87s


How the normal optimised algo works--------------------------

Sequence cut----
1. It uses the dfg to create strongly connected group(SCC) of activities.
2. It considers the SCCs as a single activity and finds how they are connected(edges between them).
3. For 2 SCC a->b, all 'a's are put in set1, and 'b's in set2.
4. Remove duplicated SCCs  and put it into a seperate list.
5. For each activity 'c' in the duplicated list, and for every activity 's' in set1, if 's' can reach 'c' and 'c' cannot reach 's', put it in set2, else put it in set1. 
5. Convert the SCCs to their orginal activities group.
6. If either of the sets are empty, then sequence cut is not possible. If the entire graph is stringly connected, you will have only 1 SCC, and hence, this cut is not possible.

Exclusive cut----
1. Using dfg, find disjoint group of activities.
2. Put 1st group to set1 and rest to set2.
3. If either of the sets are empty, then exclusive cut is not possible.

Parallel cut----
1. Go through the activities 1 by 1.
2. Put the first activity in set1.
3. For an activity 'b', if it has to-and-from edges with every activity in set1, then put it in set2.
4. Else if, if it has to-and-from edges with every activity in set2, then put it in set1.
5. Else, return false as parallel cut is not possible.
6. Also, check the extra conditions for parallel cut to be sure.

Redo cut----
1. Put start and end activities into set1.
2. For the remaining activities, starting from a start activity, if it is possible to reach a remaining activity before reaching an end activity; and starting from an end activity, if it is not possible to reach the remaining activity before reaching a start activity, then put it in set1.
3. Starting from a start activity, if it is not possible to reach a remaining activity before reaching an end activity; and starting from an end activity, if it is possible to reach the remaining activity before reaching a start activity, then put it in set2.
4. Else, return false as redo cut is not possible.
5. Also, check the extra conditions for redo cut to be sure.


How the best cut with minimum cost algo works--------------------------

Sequence cut----

1. For every pair of activities (a,b), find the total cost(edges to be removed) in order to make 'b' non-reachable to 'a'.
2. In each case, create a new dfg with those edges removed. Put 'a' in set1 and 'b' in set2.
3. For every remaining activity 'c', if 'c' is reachable to 'a', put it in set1.
4. Else, put 'c' in set2.
5. Also, keep track of the size difference of the final set1 and set2. We want it as balanced as possible.
6. Take the case with the minimum total cost. If multiple cases have same total cost, then take the one with least size difference.
7. Return the best cost, edges to be cut, set1, set2, and the new dfg.

v2----
1. For every pair of activities (a,b), find the total cost(edges to be removed) in order to make 'b' non-reachable to 'a', plus cost(edges to be added) to make 'a' reachable to 'b'.
2. In each case, create a new dfg with the necessary edges removed and added. Put 'a' in set1 and 'b' in set2.
3. For every remaining activity 'c', find cost of putting 'c' in set1 and set2, and take the lower cost option.
3.1 Cost should be calculated like this-
3.2. Cost1 = cost of edges to be removed to make set2 activities non-reachable to 'c' + cost of edges to be added to make 'c' reachable to every activity in set2.
3.3. Cost2 = cost of edges to be added to make every activity in set1 reachable to 'c'.
3.4 if cost1 is lower, put 'c' in set1. Else put 'c' in set2.
4. Also, keep track of the size difference of the final set1 and set2. We want it as balanced as possible.
5. Take the case with the minimum total cost. If multiple cases have same total cost, then take the one with least size difference.
6. Return the best cost, edges to be cut, set1, set2, and the new dfg.

Exclusive cut----
1. For every pair of activities (a,b), find the total cost(edges to be removed) in order to make 'a' non-reachable to 'b' and 'b' non-reachable to 'a'.
2. In each case, create a new dfg with those edges removed. Put 'a' in set1 and 'b' in set2.
3. For every remaining activity 'c', find the reachability of 'c' with activities of set1 and set2.
4. Based of above, put 'c' in set1 or set2 in case atleast 1 set is completely unreachable.
5. In case, both sets are reachable, find the cost c1 of making 'c' unreachable to and from activities of set1. Find the cost c2 of making 'c' unreachable to and from activities of set2.
6. Put 'c' in set2 if c1<c2. Else put it in set2.
5. Also, keep track of the size difference of the final set1 and set2. We want it as balanced as possible.
6. Take the case with the minimum total cost. If multiple cases have same total cost, then take the one with least size difference.
7. Return the best cost, edges to be cut, set1, set2, and the new dfg.
Psudocode-
For every pair of activity(a,b){
	set1={a}
	set2={b}
	r1_min_cut, r1_cost, r1_cut_edges=non_reachable(dfg,a,b)
	r2_min_cut, r2_cost, r2_cut_edges=non_reachable(dfg,b,a)
	total_min_cut, total_cost, total_cut_edges=r1_min_cut+r2_min_cut, r1_cost+r2_cost, r1_cut_edges+r2_cut_edges
	create new_dfg with edges of r1_cut_edges and r2_cut_edges removed
	for every remaining activity c{
		c_a = is_reachable(new_dfg, c,a)
		c_b = is_reachable(new_dfg, c,b)
		a_c = is_reachable(new_dfg, a,c)
		b_c = is_reachable(new_dfg, b,c)

		if((c_a or a_c) and !c_b and !b_c){
			insert c in set1
		} else if((c_b or b_c) and !c_a and !a_c){
			insert c in set2
		} else if( !(c_a or a_c or c_b or _c) ){
			insert c in set1 or set2 depending of whichever has lower elements in it.
		}
		else {
			c11_min_cut, c11_cost, c11_cut_edges=non_reachable(new_dfg,a,c)
			new_dfg_c11 = new_dfg with c11_cut_edges removed
			c12_min_cut, c12_cost, c12_cut_edges=non_reachable(new_dfg_c11,c,a)
			c1_min_cut, c1_cost, c1_cut_edges = c11_min_cut+c12_min_cut, c11_cost+c12_cost, c11_cut_edges+c12_cut_edges
			new_dfg_c1 = new_dfg_c11 with c12_cut_edges removed

			c21_min_cut, c21_cost, c21_cut_edges=non_reachable(new_dfg,b,c)
			new_dfg_c21 = new_dfg with c21_cut_edges removed
			c22_min_cut, c22_cost, c22_cut_edges=non_reachable(new_dfg_c21,c,a)
			c2_min_cut, c2_cost, c2_cut_edges = c21_min_cut+c22_min_cut, c21_cost+c22_cost, c21_cut_edges+c22_cut_edges
			new_dfg_c2 = new_dfg_c21 with c22_cut_edges removed

			if(c1_cost<c2_cost){
				insert c in set1
				total_min_cut+=c1_min_cost
				total_cost+=c1_cost
				total_cut_edges+=c1_cut_edges
				new_dfg=new_dfg_c1
			}
			if(c2_cost<c1_cost){
				insert c in set2
				total_min_cut+=c2_min_cost
				total_cost+=c2_cost
				total_cut_edges+=c2_cut_edges
				new_dfg=new_dfg_c2
			} else{
				if(size(set1)<=size(set2)){
					insert c in set1
					total_min_cut+=c1_min_cost
					total_cost+=c1_cost
					total_cut_edges+=c1_cut_edges
					new_dfg=new_dfg_c1
				} else{
					insert c in set2
					total_min_cut+=c2_min_cost
					total_cost+=c2_cost
					total_cut_edges+=c2_cut_edges
					new_dfg=new_dfg_c2
				}
			}
			
		}
	}
}

Parallel cut----
Heuristic Method---
1. Randomly divide activities into two sets: set1 and set2.
2. For each partition, calculate the cost to make it parallel i.e. adding edges. Also, which edges need to be added.
3. Iteratively try moving one activity from one set to the other. Accept a move only if it reduces the cost. Repeat until no more improvements can be found.
4. Do same as above, but with small sets of activities instead of one. 
5. Do this random division many times, and keep track of the best result.

Exhaustive Method-
1. Make all possible partitions of activities into 2 sets.
2. In each case, see the cost to make it as a valid parallel cut.
3. Keep track of the best.


REDO CUT----
1. For all start activities 's' and end activities 'e', check if 'e' is reachable from 's'. If not, return false i.e. redo cut is not possible.
2. Make a list with start-to-end activity pairs and end-to-start activity pairs.
3. Put all start and end activities in set1.
4. For each remaining activity, see if it occurs in between start-to-end pairs or between end-to-start pairs.
5. If only 1st case is true, put it in set1. If only 2nd case is true, put it in set2.
6. In case, both are true, do below.
7. First delete the activity and check if all the start-to-end activity pairs and end-to-start activity pairs are still valid. If not, return false.
8. If any start-to-end activity pair is invalid but end-to-start pairs are valid, then add it to set1. 
9. If any end-to-start activity pair is invalid but start-to-end pairs are valid, then add it to set2. 
10. Else, find the cost of removing all edges of it from activities in set1 and set2, see which is lower, and do that.

v2-
1. For all start activities 's' and end activities 'e', check if 's' is reachable from 'e'. If not, return false i.e. redo cut is not possible.
2. Put all start and end activities in set1.
4. For each remaining activity, see if it occurs in between start and end activities or between end and start activities.
5. If only 1st case is true, put it in set1. If only 2nd case is true, put it in set2.
6. In case, both are true, do below.
7. First delete the activity and check if all the start-to-end activity reachability and end-to-start activity reachability are still valid. If not, return false.
8. If any start-to-end activity reachability is invalid but end-to-start reachability are valid, then add it to set1. 
9. If any end-to-start activity reachability is invalid but start-to-end pairs are reachability, then add it to set2. 
10. Else, find the cost of removing all edges of it from activities in set1 and set2, see which is lower, and do that.





Possible names-
1. User-guided cut recommendations for complex Object-Centric event logs.
2. Process model discovery through Cut effort estimation in Object-Centric event Logs.
3. Improving cut detection in Object-Centric Process Discovery.
4. Smart Cut suggestions in Object-Centric Process Discovery.
5. A Framework for dealing with inseparable activities in Object-Centric event logs.
6. Interactive Cut evaluation in highly connected Object-Centric event logs.

visual, object centric, , guided, process discovery, 




-------------------------------------
Proof for optimal guaratee of sequence cut.

Important note-
The rule for sequence cut is for activity 'a' in set1 and for every activity 'b' in set2, 'a' should be able to reach 'b', and 'b' cannot not reach 'a'.
This algorithm only checks the unreachability part of the rule i.e. "'b' cannot not reach 'a'" part. If the reachability part was false in some case, there would be a sequence cut with 0 cost.
This is why this algorithm ignores this checking reachability step.

Now coming to the proof.

Let's assume there is an optimal division of activities set1= (...,a,....) & set2=(...,b,...) with cost=m which gives the optimal sequence cut.
We know that in our algorithm, we definitely consider a case starting with set1=(a) and set2=(b) cost=n at this stage. The cost does not increase when assigning the remaining activities.
In the optimal case, as 'a' must be unreachable from 'b', then the cost 'm' >='n'.
So, the minimum cost to divide the 2 sets by a sequence cut must be 'n'.
If you are assigning a remaining activity 'c' to set1 as 'c' can reach 'a', the other activities in set2 are guaranteed to be unreachable to 'c' as that would mean, it can also reach 'a' and thats not possible.
If you are assigning a remaining activity 'c' to set2 as 'c' cannot reach 'a', 'a' must to reachable to 'c'. If this is false, it would mean a sequence cut with cost=0 is possible.
So the sequence rules are not being violated.



